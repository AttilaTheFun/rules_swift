# Copyright 2023 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Defines a rule for compiling Swift source files from proto_libraries.
"""

load(
    "@bazel_skylib//lib:dicts.bzl", 
    "dicts",
)
load(
    "@bazel_skylib//lib:paths.bzl",
    "paths",
)
load(
    "//swift:swift.bzl",
    "SwiftInfo",
    "swift_common",
)

SwiftProtoCompilerInfo = provider(
    doc = "Information and dependencies needed to generate Swift code from protos",
    fields = {
        "compile": """A function with the signature:

    def compile(ctx, compiler, protos, imports, importpath)

Where:
- ctx is the rule's context
- compiler is this SwiftProtoCompilerInfo
- protos is a list of ProtoInfo providers for protos to compile
- imports is a depset of strings mapping proto import paths to Swift import paths
- importpath is the import path of the Swift library being generated

The function should declare output .swift files and actions to generate them.
It should return a list of .swift Files to be compiled by the Go compiler.
""",
        "deps": """List of targets providing SwiftInfo and CcInfo.
These are added as implicit dependencies for any swift_proto_library using this
compiler. Typically, these are Well Known Types and proto runtime libraries.
""",
        "internal": "Opaque value containing data used by compile.",
    },
)

def swift_proto_compile(ctx, compiler, protos, imports, importpath):
    """Invokes protoc to generate Swift sources for a given set of protos

    Args:
        ctx: the rule's context
        compiler: a SwiftProtoCompilerInfo provider.
        protos: list of ProtoInfo providers for protos to compile.
        imports: depset of strings mapping proto import paths to Swift import paths.
        importpath: the import path of the Swift library being generated.

    Returns:
        A list of .swift Files generated by the compiler.
    """

    # Declare the swift files that will be generated
    swift_srcs = []
    outpath = None
    proto_paths = {}
    desc_sets = []
    for proto in protos:
        desc_sets.append(proto.transitive_descriptor_sets)
        for src in proto.check_deps_sources.to_list():
            path = proto_path(src, proto)
            if path in proto_paths:
                if proto_paths[path] != src:
                    fail("proto files {} and {} have the same import path, {}".format(
                        src.path,
                        proto_paths[path].path,
                        path,
                    ))
                continue
            proto_paths[path] = src

            suffixes = compiler.internal.suffixes
            for suffix in suffixes:
                out = ctx.declare_file(
                    ctx,
                    path = importpath + "/" + src.basename[:-len(".proto")],
                    ext = suffix,
                )
                swift_srcs.append(out)
            if outpath == None:
                outpath = swift_srcs[0].dirname[:-len(importpath)]
    transitive_descriptor_sets = depset(direct = [], transitive = desc_sets)
    print("swift_srcs: ", swift_srcs)

    # Build the arguments for protoc:
    args = ctx.actions.args()
    # args.add("-protoc", compiler.internal.protoc)
    args.add("-importpath", importpath)
    args.add("-out_path", outpath)
    args.add("-plugin", compiler.internal.plugin)
    args.add_all(compiler.internal.options, before_each = "-option")
    if compiler.internal.import_path_option:
        args.add_all([importpath], before_each = "-option", format_each = "import_path=%s")
    args.add_all(transitive_descriptor_sets, before_each = "-descriptor_set")
    args.add_all(swift_srcs, before_each = "-expected")
    args.add_all(imports, before_each = "-import")
    args.add_all(proto_paths.keys())
    args.use_param_file("-param=%s")

    # Run protoc:
    ctx.actions.run(
        inputs = depset(
            direct = [
                # compiler.internal.swift_protoc,
                compiler.internal.protoc,
                compiler.internal.plugin,
            ],
            transitive = [transitive_descriptor_sets],
        ),
        outputs = swift_srcs,
        progress_message = "Generating into %s" % swift_srcs[0].dirname,
        mnemonic = "SwiftProtocGen",
        # executable = compiler.internal.swift_protoc,
        executable = compiler.internal.protc,
        arguments = [args],
    )

    return swift_srcs

def proto_path(src, proto):
    """proto_path returns the string used to import the proto. 

    This is the proto source path within its repository, 
    adjusted by import_prefix and strip_import_prefix.

    Args:
        src: the proto source File.
        proto: the ProtoInfo provider.

    Returns:
        An import path string.
    """
    if proto.proto_source_root == ".":
        # true if proto sources were generated
        prefix = src.root.path + "/"
    elif proto.proto_source_root.startswith(src.root.path):
        # sometimes true when import paths are adjusted with import_prefix
        prefix = proto.proto_source_root + "/"
    else:
        # usually true when paths are not adjusted
        prefix = paths.join(src.root.path, proto.proto_source_root) + "/"
    if not src.path.startswith(prefix):
        # sometimes true when importing multiple adjusted protos
        return src.path
    return src.path[len(prefix):]

def _swift_proto_compiler_impl(ctx):
    # go = swift_context(ctx)
    # library = go.new_library(go)
    # source = go.library_to_source(go, ctx.attr, library, ctx.coverage_instrumented())
    return [
        SwiftProtoCompilerInfo(
            deps = ctx.attr.deps,
            compile = swift_proto_compile,
            internal = struct(
                suffixes = ctx.attr.suffixes,
                # swift_protoc = ctx.executable._swift_protoc,
                protoc = ctx.executable._protoc,
                plugin = ctx.executable.plugin,
            ),
        ),
    ]

swift_proto_compiler = rule(
    implementation = _swift_proto_compiler_impl,
    attrs = dicts.add(
        swift_common.toolchain_attrs(),
        {
            "deps": attr.label_list(
                default = [],
                doc = """List of targets providing SwiftInfo and CcInfo.
                These are added as implicit dependencies for any swift_proto_library using this
                compiler. Typically, these are Well Known Types and proto runtime libraries.
                """,
                providers = [SwiftInfo],
            ),
            "suffixes": attr.string_list(
                default = [".pb.swift"],
                doc = """Suffix used for swift files generated from protos.

                E.g.
                foo.proto => foo.pb.swift
                foo_service.proto => foo.grpc.swift

                Each compiler target should configure this based on the suffix applied to the generated files.
                """,
            ),
            "plugin": attr.label(
                default = "//tools/protoc_wrapper:ProtoCompilerPlugin",
                doc = """A proto compiler plugin. 
                
                E.g.
                "//tools/protoc_wrapper:protoc-gen-grpc-swift"
                "//tools/protoc_wrapper:ProtoCompilerPlugin"

                We provide two compiler targets:
                "//proto:swift_proto"
                "//proto:swift_grpc"
                Which use this attribute to configure protoc with their respective plugins.
                """,
                executable = True,
                cfg = "exec",
            ),
            "plugin_name": attr.string(
                default = "swift",
                doc = """Name of plugin passed to protoc.

                E.g.
                protoc --plugin=protoc-gen-NAME=path/to/plugin/binary

                This name will be used to prefix the option and output directory arguments.

                E.g.
                protoc --plugin=protoc-gen-NAME=path/to/mybinary --NAME_out=OUT_DIR --NAME_opt=Visibility=Public

                See the protobuf API reference for more information: 
                https://protobuf.dev/reference/cpp/api-docs/google.protobuf.compiler.plugin
                """,
            ),
            "plugin_options": attr.string_dict(
                default = {
                    "Visibility": "Public",
                },
                doc = """Dictionary of plugin options passed to the plugin.

                These are prefixed with the plugin_name + "_opt".

                E.g.
                plugin_name = "swift"
                plugin_options = {
                    "Visibility": "Public",
                    "FileNaming": "FullPath",
                }

                Would be passed to protoc as:
                protoc \
                  --plugin=protoc-gen-NAME=path/to/plugin/binary \
                  --NAME_opt=Visibility=Public \
                  --NAME_opt=FileNaming=FullPath
                """,
            ),
            # TODO: rules_go created a Go binary which invokes protoc (passed as an input + CLI argument).
            # This generate the files in a temporary directory and then copied them to the desired location.
            # It seemed like this was primarily to work around Windows path issues, so hopefully it's not necessary here.
            # "_swift_protoc": attr.label(
            #     executable = True,
            #     cfg = "exec",
            #     default = "//go/tools/builders:go-protoc",
            # ),
            "_protoc": attr.label(
                cfg = "exec",
                default = "//tools/protoc_wrapper:protoc",
                executable = True,
            ),
        }
    ),
)